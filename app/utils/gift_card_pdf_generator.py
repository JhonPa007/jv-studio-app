import os
from reportlab.lib.pagesizes import landscape, letter
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from flask import current_app

def generate_gift_card_pdf(code, amount, recipient_name, from_name=None, package_name=None, services_text=None, expiration_date=None, description=None, dedication=None):
    """
    Generates a Gift Card PDF with a specific business card size (85mm x 45mm).
    Returns the absolute path to the generated PDF.
    """
    try:
        static_folder = current_app.static_folder
        output_filename = f"gift_card_{code}.pdf"
        output_dir = os.path.join(static_folder, 'pdf', 'gift_cards')
        os.makedirs(output_dir, exist_ok=True)
        output_path = os.path.join(output_dir, output_filename)
        
        # Dimensions: 85mm x 45mm
        from reportlab.lib.units import mm
        width, height = (85 * mm, 45 * mm)
        
        c = canvas.Canvas(output_path, pagesize=(width, height))
        
        # --- Background ---
        # 0. Clip to page bounds to prevent spillover
        c.saveState()
        path = c.beginPath()
        path.rect(0, 0, width, height)
        c.clipPath(path, stroke=0)

        bg_image_path = os.path.join(static_folder, 'img', 'gift_card_bg.jpg')
        if os.path.exists(bg_image_path):
            from reportlab.lib.utils import ImageReader
            img = ImageReader(bg_image_path)
            img_w, img_h = img.getSize()
            
            # Detect orientation match
            # Card is horizontal (w > h). Image might be vertical.
            # If Image is Vertical (h > w), we rotate it 90 degrees to fit better
            # while conserving proportion and filling the card.
            
            if img_h > img_w:
                # Rotate canvas logic
                # To rotate image: translate to center, rotate, draw centered
                c.translate(width/2, height/2)
                c.rotate(90)
                # Now the coordinate system is rotated.
                # Width becomes Height-ish.
                # Effective "Width" to fill is now the Card's Width (85mm)
                # But in rotated space, X axis is ...
                # Let's simple drawImage with rotation support or transform.
                # Actually, simpler: drawImage supports specific rect.
                # We want the image to COVER the 85x45 area.
                
                # If rotated 90deg, the image's height maps to card width (85), width to card height (45).
                # New Aspect after rotation = img_w / img_h (approx 0.5)
                # Card Aspect = 85/45 (approx 1.9)
                
                # Wait, if I rotate a vertical image 90 deg, it looks like a landscape image with aspect > 1 presumably?
                # No, if it's 1000x2000. Rotated it behaves like 2000x1000. Aspect 2.0.
                # Card is 85x45. Aspect 1.88.
                # Perfect! 2.0 is close to 1.88.
                
                # So:
                # 1. Transform: Rotate 90 around center.
                # 2. Draw Image centered at (0,0) in rotated system?
                
                # Reset translate to make math easier? No, keep it.
                # We are at center (42.5, 22.5). 
                # Rotated 90 deg. X points UP. Y points LEFT.
                # The image needs to be drawn such that it covers the original rectangle.
                
                # Actually, ImageReader doesn't rotate the pixels. We rotate context.
                # Let's use `drawImage` passing the image.
                
                # Calculate dimensions in ROTATED space.
                # The image (w, h) acts like (h, w).
                # Scale so new_width (img_h) >= card_width (85) OR new_height (img_w) >= card_height (45).
                # We want COVER.
                
                # Rotated Image Width = img_h. Rotated Image Height = img_w.
                # Scale factor k. k * img_h >= 85 and k * img_w >= 45.
                # k = max(85/img_h, 45/img_w).
                
                # Wait, drawing in rotated context:
                # If we rotate 90, the visual output is rotated.
                # If the image content is distinct (e.g. text), it will be sideways.
                # BUT if it's a pattern, it's fine.
                # If it's the "Gift Card" text design provided by user, ROTATING IT IS BAD if it has text.
                # The user's image likely HAS text "JV Studio" etc in the design?
                # Screenshot shows "JV STUDIO" text generated by ME on top.
                # Screenshot `uploaded_media_1770815677928.png` shows a dark background with gold swirls.
                # It does NOT look like it has embedded text.
                # So rotation is safe and desirable to fill the space.
                
                pass # Logic handled below
                
                # Simplified rotation approach:
                # Just swap w/h for calculation, then use rotate(90) and draw.
                
                # Re-do: 
                # 1. Translate to center
                # 2. Rotate 90
                # 3. Draw image centered at new (0,0) with calculated W/H
                
                # Aspect of rotated image = img_h / img_w
                # We want to fill width mainly (85mm).
                
                c.restoreState() # Restore from clip
                c.saveState() # Save again for rotation
                path = c.beginPath()
                path.rect(0, 0, width, height)
                c.clipPath(path, stroke=0)
                
                c.translate(width/2, height/2)
                c.rotate(90) # or -90? User said "Horizontal". Vertical bg usually needs -90 to lie on side?
                # Let's try -90 (Clockwise 90 visually creates landscape from portrait usually? No. 
                # Portrait: | |. Landscape: --. Rotate 90 deg -> --.
                
                # Calculate Draw Dimensions
                # In this rotated system, we are drawing the image 'upright' relative to itself,
                # but the context is rotated.
                # So we draw (img_w, img_h).
                # We need it to cover the area.
                # The area in rotated frame is (Height x Width) essentially (45 x 85).
                # Wait, if we rotate 90, the X-axis aligns with original Y.
                # So the aperture is 45 (wide) x 85 (high) in rotated frame?
                # Yes.
                # Image is img_w x img_h.
                # We need to cover 45 x 85 with img_w x img_h.
                # Scale k = max(45/img_w, 85/img_h).
                # Then draw centered.
                
                scale = max(height/float(img_w), width/float(img_h))
                draw_w = img_w * scale
                draw_h = img_h * scale
                
                c.drawImage(bg_image_path, -draw_w/2, -draw_h/2, width=draw_w, height=draw_h)
                
            else:
                # Standard drawing (Horizontal Image)
                # Maximize coverage
                scale = max(width/float(img_w), height/float(img_h))
                draw_w = img_w * scale
                draw_h = img_h * scale
                c.drawImage(bg_image_path, (width - draw_w)/2, (height - draw_h)/2, width=draw_w, height=draw_h)

        else:
            # Fallback
            c.setFillColorRGB(0.1, 0.1, 0.1)
            c.rect(0, 0, width, height, fill=1)
        
        c.restoreState() # Restore clip/rotate state
        
        # --- Fonts ---
        # Register fonts
        font_main = "Helvetica-Bold"
        font_reg = "Helvetica"
        
        font_path_bold = os.path.join(static_folder, 'fonts', 'AGENCYB.TTF')
        font_path_reg = os.path.join(static_folder, 'fonts', 'AGENCYR.TTF')
        
        if os.path.exists(font_path_bold):
            pdfmetrics.registerFont(TTFont('AgencyFB-Bold', font_path_bold))
            font_main = 'AgencyFB-Bold'
            
        if os.path.exists(font_path_reg):
            pdfmetrics.registerFont(TTFont('AgencyFB-Reg', font_path_reg))
            font_reg = 'AgencyFB-Reg'

        # --- Content Layout (Scaling for 85x45mm) ---
        
        # 1. Header Row
        # "JV STUDIO" (Top Left)
        c.setFillColor(colors.white) # or slightly off-white
        c.setFont(font_main, 8) 
        c.drawString(3 * mm, height - 6 * mm, "JV STUDIO")

        # "GIFT CARD" (Top Center)
        c.setFillColor(colors.gold)
        c.setFont(font_main, 10)
        c.drawCentredString(width / 2, height - 6 * mm, "GIFT CARD")

        # "CÓDIGO: ..." (Top Right)
        c.setFillColor(colors.white)
        c.setFont(font_reg, 5) # Small
        c.drawRightString(width - 3 * mm, height - 6 * mm, f"CÓDIGO: {code}")

        # 2. Main Title (Service/Package) - CENTER
        c.setFillColor(colors.gold)
        c.setFont(font_main, 14) # Large
        
        main_text = ""
        if package_name:
            main_text = package_name.upper()
            if len(main_text) > 20: c.setFont(font_main, 11)
        else:
            main_text = f"S/ {float(amount):.2f}"
            
        c.drawCentredString(width / 2, height / 2 + 2 * mm, main_text)
        
        # 3. Description - CENTER Below Title
        c.setFillColor(colors.white)
        c.setFont(font_reg, 6)
        
        text_to_display = description if description else services_text
        
        if package_name and text_to_display:
             from reportlab.lib.utils import simpleSplit
             avail_width = 75 * mm
             lines = simpleSplit(text_to_display, font_reg, 6, avail_width)
             
             y_offset = height / 2 - 2 * mm
             for line in lines[:3]: # Limit to 3 lines max
                 c.drawCentredString(width / 2, y_offset, line)
                 y_offset -= 2.5 * mm
        else:
             pass

        # 4. Custom Message ("Para mi hermanito...")
        if dedication:
             # Golden, Italic/Script-like if possible, else just FontReg
             # If we want italic we need to register it or use standard standard fonts
             # Let's use Helvetica-Oblique for standard italic
             c.setFont("Helvetica-Oblique", 7)
             c.setFillColor(colors.gold)
             # Draw centered but slightly to the left/right? 
             # Reference has it leftish but centered looks safer.
             # Reference: "Para mi hermanito..." is yellowish and scripty.
             
             # Calculate position - below description
             dedication_y = 11 * mm # Just above footer area
             c.drawCentredString(width / 2, dedication_y, f'"{dedication}"')

        # 5. Footer Area
        c.setFont(font_reg, 6)
        c.setFillColor(colors.white)
        
        # De: ...
        if from_name:
            c.drawString(3 * mm, 7 * mm, f"De: {from_name}")
            
        # Para: ...
        c.drawString(3 * mm, 3 * mm, f"Para: {recipient_name}")

        # Vence: ...
        if expiration_date:
            c.drawRightString(width - 3 * mm, 7 * mm, f"VENCE: {expiration_date}")

        # Validation Text
        c.setFont(font_reg, 4)
        c.drawRightString(width - 3 * mm, 3 * mm, "VÁLIDO PARA CANJE EN JV STUDIO")

        c.save()
        return output_path
        
    except Exception as e:
        print(f"Error creating PDF: {e}")
        return None
